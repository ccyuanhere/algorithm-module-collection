按照以下格式要求，我要生成能量检测算法的示例，给我生成一份代码文件夹，文件夹命名为algorithm_ED。                                                                                                                                                         一、标准目录结构
algorithm_name/
├── run.py                      # 【必需】标准运行接口
├── model.py                    # 【必需】核心算法逻辑
├── config.json                 # 【必需】默认参数配置
├── meta.json                   # 【必需】元信息
├── README.md                   # 【必需】使用说明
├── requirements.txt            # 【必需】依赖列表（可为空）
├── make.py                     # 【可选】数据生成脚本
├── assets/                     # 【推荐】静态演示图
│   ├── algorithm_structure.png
│   └── example_visualization.png
├── data/                       # 【必需】示例输入输出数据
│   ├── example_input.npy
│   ├── example_output.npy
│   └── example_labels.npy
└── models/                     # 【可选】模型文件夹
    ├── pretrained_model.pt
    └── checkpoint.pkl
二、核心文件规范
1. run.py - 标准接口【重点】
这是最重要的文件，所有算法必须严格遵循此接口规范！
def run(input_data: Dict[str, Any], config_path: Optional[str] = None) -> Dict[str, Any]:
    """
    标准运行接口 - 所有算法的统一入口
    
    Args:
        input_data (dict): 输入数据字典，根据算法类型包含不同字段
        config_path (str, optional): 配置文件路径
        
    Returns:
        dict: 统一格式的返回结果
        {
            "result": Any,        # 主结果（必需）
            "metrics": dict,      # 可选评估值（可为空字典）
            "log": str,          # 日志信息
            "success": bool      # 是否成功
        }
    """                                                                                                                                                                 三、input_data格式：input_data = {
    "signal": np.ndarray,     # 输入信号
    "labels": np.ndarray,     # 标签（训练时需要）
    "mode": "train"           # 运行模式："train", "predict", "evaluate"
}                                                                                                                                                                           model.py - 核心逻辑
包含算法的主要实现逻辑，通常包含一个process函数供run.py调用：
def process(config: dict, signal: np.ndarray, labels: Optional[np.ndarray] = None) -> Dict[str, Any]:
    """
    处理函数 - 实际的算法逻辑
    
    Args:
        config: 配置参数
        signal: 输入信号
        labels: 标签（可选）
        
    Returns:
        dict: 处理结果
    """
重要原则：
将静态参数（如网络层数、KNN邻居数等）直接写在model.py中
将动态参数（如距离函数、输入维度等）放在config.json中
3. config.json - 动态参数配置
只包含需要动态调整的参数，静态参数直接写在代码中！
{
    "distance_metric": "minkowski",    // 动态参数：可调整的算法选项
    "distance_p": 2,                   // 动态参数：算法超参数
    "signal_length": "rand",           // 动态参数：输入维度相关
    "feature_selection": {             // 动态参数：功能开关
        "use_iq": true,
        "use_amplitude": true,
        "use_phase": true,
        "use_spectrum": true
    }
}

不要在config.json中放置的参数：
神经网络层数、隐藏单元数
KNN中的K值、分类类别数
模型架构相关的固定参数
4. meta.json - 元信息描述
用于系统级调度和流程控制：
{
    "name": "算法名称",
    "author": "开发者姓名",
    "task": "algorithm",  // 必须是：generator, preprocessor, separator, algorithm, analyzer
    "input_type": ["np.ndarray[float32]"],
    "input_size": "batch_size * 2 * rand",  // 使用rand表示可变长度
    "output_type": ["np.ndarray[int32]", "np.ndarray[float32]"],
    "output_size": "batch_size * 1, batch_size * num_classes",
    "description": "详细的算法描述，说明功能和适用场景",
    "version": "1.0",
    "tags": ["signal_processing", "classification", "machine_learning"],
    "dependencies": ["config.json"],
    "example_input": "data/example_input.npy",
    "supported_features": ["特性1", "特性2"]  // 算法支持的特性
}

input_size/output_size规范：
使用rand表示任意长度
使用rand1, rand2表示不同的可变长度
例："batch_size * 3 * rand1 * rand2"表示3通道、长宽不同的图像
四、数据文件规范
1. data/目录
必须包含示例数据，用于测试和演示：
example_input.npy：示例输入数据
example_output.npy：期望输出数据
example_labels.npy：标签数据（如需要）
可以使用make.py生成测试数据：
# data/目录下运行
python ../make.py
2. models/目录
存放预训练模型、权重文件等：
.pt文件（PyTorch）
.pkl文件（Scikit-learn）
.npz文件（NumPy）
3. assets/目录
存放算法相关的可视化资源：
算法结构图
效果演示图
流程示意图